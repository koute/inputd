use {
    std::{
        collections::{
            HashMap,
            HashSet
        },
        path::{
            Path,
            PathBuf
        },
        sync::{
            atomic::{
                AtomicBool,
                Ordering
            },
            Arc,
            Weak
        }
    },
    structopt::{
        StructOpt
    },
    linux_input::{
        AbsoluteAxisBit,
        Bus,
        DeviceId,
        Device,
        EventBit,
        EventKind,
        ForceFeedback,
        Key,
        RelativeAxis
    },
    parking_lot::{
        Condvar,
        Mutex,
        RwLock
    },
    crate::{
        config::{
            Config,
            DeviceKind
        }
    }
};

mod config;

#[derive(StructOpt, Debug)]
enum Opt {
    /// Lists available devices.
    List {
        /// Shows all devices.
        #[structopt(short = "a", long)]
        all: bool,
        paths: Vec< PathBuf >
    },
    /// Prints events generated by a device.
    PrintEvents {
        #[structopt(short = "e", long)]
        exclusive: bool,
        path: PathBuf
    },
    /// Starts with a given configuration file.
    #[structopt(name="start")]
    Start {
        /// A path to the config file.
        #[structopt(parse(from_os_str))]
        config: PathBuf
    }
}

struct DeviceInfo {
    name: String,
    id: DeviceId,
    key_bits: Vec< Key >,
    relative_axis_bits: Vec< RelativeAxis >,
    absolute_axis_bits: Vec< AbsoluteAxisBit >,
    force_feedback_bits: Vec< ForceFeedback >
}

impl DeviceInfo {
    fn get( device: &mut Device ) -> Option< Self > {
        let name = device.name().ok()?;
        let id = device.id().ok()?;
        let key_bits: Vec< _ > = device.event_bits_of_kind::< Key >().ok()?.collect();
        let relative_axis_bits: Vec< _ > = device.event_bits_of_kind::< RelativeAxis >().ok()?.collect();
        let absolute_axis_bits: Vec< _ > = device.absolute_axis_event_bits().ok()?.collect();
        let force_feedback_bits: Vec< _ > = device.event_bits_of_kind::< ForceFeedback >().ok()?.collect();

        Some( DeviceInfo {
            name,
            id,
            key_bits,
            relative_axis_bits,
            absolute_axis_bits,
            force_feedback_bits
        })
    }

    fn guess_type( &self ) -> Option< DeviceKind > {
        // TODO: Add better detection by checking bits.
        if self.key_bits.len() >= 84 {
            return Some( DeviceKind::Keyboard );
        } else if self.key_bits.len() >= 10 && self.key_bits.len() <= 20 {
            return Some( DeviceKind::Gamepad );
        } else if self.relative_axis_bits.len() >= 2 {
            return Some( DeviceKind::Mouse );
        }

        None
    }

    fn match_with_config( &self, filter: &crate::config::DeviceFilter ) -> bool {
        let mut bus_matches = true;
        let mut vendor_matches = true;
        let mut product_matches = true;
        let mut version_matches = true;
        let mut name_matches = true;
        let mut kind_matches = true;

        if let Some( bus ) = filter.bus {
            bus_matches = bus == self.id.bus;
        }

        if let Some( vendor ) = filter.vendor {
            vendor_matches = vendor == self.id.vendor;
        }

        if let Some( not_vendor ) = filter.not_vendor {
            vendor_matches &= not_vendor != self.id.vendor;
        }

        if let Some( product ) = filter.product {
            product_matches = product == self.id.product;
        }

        if let Some( version ) = filter.version {
            version_matches = version == self.id.version;
        }

        if let Some( ref name ) = filter.name {
            name_matches = *name == self.name;
        }

        if let Some( kind ) = filter.kind {
            kind_matches = self.guess_type().map( |guessed_kind| guessed_kind == kind ).unwrap_or( false );
        }

        bus_matches && vendor_matches && product_matches && version_matches && name_matches && kind_matches
    }
}

fn list_devices() -> Vec< PathBuf > {
    let mut paths = Vec::new();
    for entry in std::fs::read_dir( "/dev/input" ).unwrap() {
        let entry = entry.unwrap();
        if !entry.file_name().to_str().unwrap().starts_with( "event" ) {
            continue;
        }
        paths.push( entry.path() );
    }
    paths.sort();
    paths.sort_by_key( |path| {
        let path = path.to_str().unwrap();
        let digits = path.bytes().rev().take_while( |byte| byte.is_ascii_digit() ).count();
        let nth: u32 = path[ path.len() - digits.. ].parse().unwrap();
        nth
    });
    paths
}

static RUNNING: AtomicBool = AtomicBool::new( true );

fn get_rdev( path: &Path ) -> Result< (u32, u32), std::io::Error > {
    use std::os::unix::fs::MetadataExt;

    let stat = std::fs::metadata( path )?;
    let rdev = stat.rdev();
    let major = nix::sys::stat::major( rdev );
    let minor = nix::sys::stat::minor( rdev );
    let rdev = (major as u32, minor as u32);

    Ok( rdev )
}

struct DeviceState {
    global_state: Weak< GlobalState >,
    path: PathBuf,
    device: Device,
    info: DeviceInfo,
    matched_filters: Vec< String >,
    scripts: Vec< ScriptInstance >,
    old_permissions: Option< std::fs::Permissions >,
    exclusive: bool
}

struct VirtualDeviceState {
    global_state: Weak< GlobalState >,
    internal_name: String,
    rdev: (u32, u32),
    path: PathBuf,
    device: linux_input::VirtualDevice
}

enum AnyDeviceState {
    Physical( Arc< DeviceState > ),
    Virtual( Arc< VirtualDeviceState > )
}

impl AnyDeviceState {
    fn emit< T >( &self, body: T ) -> Result< (), std::io::Error > where T: AsRef< linux_input::InputEventBody > {
        match *self {
            AnyDeviceState::Physical( ref device_state ) => {
                log::trace!( ">> {:?}: {:?}", device_state.path, body.as_ref() );
                device_state.device.emit( body )
            },
            AnyDeviceState::Virtual( ref virtual_device_state ) => {
                log::trace!( ">> {:?}: {:?}", virtual_device_state.path, body.as_ref() );
                virtual_device_state.device.emit( body )
            }
        }
    }
}

struct GlobalState {
    config: Config,
    scripts: Vec< Arc< Script > >,
    devices_by_internal_name: RwLock< HashMap< String, Vec< Arc< DeviceState > > > >,
    virtual_device_by_rdev: RwLock< HashMap< (u32, u32), Arc< VirtualDeviceState > > >,
    virtual_device_by_internal_name: RwLock< HashMap< String, Arc< VirtualDeviceState > > >,
}

fn find_device_for_ff( global_state: &GlobalState, target: &str ) -> Option< Arc< DeviceState > > {
    let devices_by_internal_name = global_state.devices_by_internal_name.read();
    let device_states = match devices_by_internal_name.get( target ) {
        Some( device_states ) => device_states,
        None => return None
    };

    if let Some( device_state ) = device_states.iter().find( |device_state| !device_state.info.force_feedback_bits.is_empty() ) {
        Some( device_state.clone() )
    } else {
        None
    }
}

impl Drop for VirtualDeviceState {
    fn drop( &mut self ) {
        if let Some( global ) = self.global_state.upgrade() {
            global.virtual_device_by_rdev.write().remove( &self.rdev );
            global.virtual_device_by_internal_name.write().remove( &self.internal_name );
        }
    }
}

impl VirtualDeviceState {
    fn force_feedback_thread_main( &self, redirect_to: String ) {
        let mut effect_map = HashMap::new();
        let mut device_by_effect = HashMap::new();
        while RUNNING.load( Ordering::Relaxed ) {
            let event = match self.device.poll_force_feedback( None ).unwrap() {
                Some( event ) => event,
                None => continue
            };

            let global_state = match self.global_state.upgrade() {
                Some( global_state ) => global_state,
                None => break
            };

            match event {
                linux_input::ForceFeedbackRequest::Upload( request ) => {
                    effect_map.insert( request.effect_id(), request.raw_effect() );

                    let device_state = if let Some( device_state ) = find_device_for_ff( &global_state, &redirect_to ) {
                        device_state
                    } else {
                        continue;
                    };

                    match device_state.device.upload_force_feedback_effect( request.raw_effect() ) {
                        Ok( target_effect_id ) => {
                            device_by_effect.insert( request.effect_id(), (Arc::downgrade( &device_state ), target_effect_id) );
                        },
                        Err( error ) => {
                            log::warn!( "Failed to upload a force feedback effect on device '{}': {}", device_state.info.name, error );
                        }
                    }

                    if let Err( error ) = request.complete() {
                        log::error!( "Failed to complete a force feedback upload request: {}", error );
                    }
                },
                linux_input::ForceFeedbackRequest::Erase( request ) => {
                    effect_map.remove( &request.effect_id() );

                    let (device_state, target_effect_id) = match device_by_effect.remove( &request.effect_id() ) {
                        Some( effect ) => effect,
                        None => continue
                    };
                    let device_state = match device_state.upgrade() {
                        Some( device_state ) => device_state,
                        None => continue
                    };

                    if let Err( error ) = device_state.device.erase_force_feedback_effect( target_effect_id ) {
                        if error.as_errno().map( |error| error == nix::errno::Errno::ENODEV ).unwrap_or( false ) {
                            device_by_effect.remove( &request.effect_id() );
                        } else {
                            log::warn!( "Failed to erase a force feedback effect on device '{}': {}", device_state.info.name, error );
                        }
                    }

                    if let Err( error ) = request.complete() {
                        log::error!( "Failed to complete a force feedback erase request: {}", error );
                    }
                },
                linux_input::ForceFeedbackRequest::Enable { effect_id, cycle_count } => {
                    let mut found = false;
                    if let Some( (device_state, target_effect_id) ) = device_by_effect.get( &effect_id ) {
                        if let Some( device_state ) = device_state.upgrade() {
                            if let Err( error ) = device_state.device.enable_force_feedback_effect( *target_effect_id, cycle_count ) {
                                if error.raw_os_error() == Some( libc::ENODEV ) {
                                    device_by_effect.remove( &effect_id );
                                } else {
                                    log::warn!( "Failed to enable a force feedback effect on device '{}': {}", device_state.info.name, error );
                                    found = true;
                                }
                            } else {
                                found = true;
                            }
                        }
                    }

                    if !found {
                        if let Some( raw_effect ) = effect_map.get( &effect_id ) {
                            if let Some( device_state ) = find_device_for_ff( &global_state, &redirect_to ) {
                                match device_state.device.upload_force_feedback_effect( *raw_effect ) {
                                    Ok( target_effect_id ) => {
                                        device_by_effect.insert( effect_id, (Arc::downgrade( &device_state ), target_effect_id) );
                                        if let Err( error ) = device_state.device.enable_force_feedback_effect( target_effect_id, cycle_count ) {
                                            log::warn!( "Failed to enable a force feedback effect on device '{}': {}", device_state.info.name, error );
                                        }
                                    },
                                    Err( error ) => {
                                        log::warn!( "Failed to upload a force feedback effect on device '{}': {}", device_state.info.name, error );
                                    }
                                }
                            }
                        }
                    }
                },
                linux_input::ForceFeedbackRequest::Disable { effect_id } => {
                    if let Some( (device_state, target_effect_id) ) = device_by_effect.get( &effect_id ) {
                        if let Some( device_state ) = device_state.upgrade() {
                            if let Err( error ) = device_state.device.disable_force_feedback_effect( *target_effect_id ) {
                                if error.raw_os_error() == Some( libc::ENODEV ) {
                                    device_by_effect.remove( &effect_id );
                                } else {
                                    log::warn!( "Failed to disable a force feedback effect on device '{}': {}", device_state.info.name, error );
                                }
                            }
                        }
                    }
                },
                linux_input::ForceFeedbackRequest::Other { .. } => {}
            }
        }
    }
}

impl DeviceState {
    fn thread_main( self: Arc< DeviceState > ) {
        struct Cleanup {
            device_state: Arc< DeviceState >,
            is_running: Arc< AtomicBool >,
            condvar: Arc< Condvar >
        }

        let condvar = Arc::new( Condvar::new() );
        let is_running = Arc::new( AtomicBool::new( true ) );
        let cleanup = Cleanup {
            device_state: self.clone(),
            is_running: is_running.clone(),
            condvar: condvar.clone()
        };

        impl Drop for Cleanup {
            fn drop( &mut self ) {
                self.is_running.store( false, Ordering::SeqCst );
                self.condvar.notify_all();

                if let Some( global_state ) = self.device_state.global_state.upgrade() {
                    let mut devices_by_internal_name = global_state.devices_by_internal_name.write();
                    for internal_name in &self.device_state.matched_filters {
                        if let Some( list ) = devices_by_internal_name.get_mut( internal_name ) {
                            list.retain( |other_device_state| !Arc::ptr_eq( &self.device_state, &other_device_state ) );
                        }
                    }
                }

                if let Some( ref old_permissions ) = self.device_state.old_permissions {
                    let _ = std::fs::set_permissions( &self.device_state.path, old_permissions.clone() );
                }
            }
        }

        let pipe = Arc::new( Mutex::new( Vec::new() ) );
        let thread_handle = {
            let pipe = pipe.clone();
            let condvar = condvar.clone();
            let itself = self.clone();
            std::thread::spawn( move || {
                let mut buffer: Vec< linux_input::InputEvent > = Vec::new();
                let mut source = pipe.lock();
                let mut pressed_alt = false;
                let mut pressed_ctrl = false;
                let mut pressed_escape = false;
                let mut pressed_pause = false;

                while RUNNING.load( Ordering::Relaxed ) {
                    if source.is_empty() {
                        condvar.wait( &mut source );
                        continue;
                    }

                    std::mem::swap( &mut buffer, &mut source );
                    std::mem::drop( source );

                    for event in buffer.drain(..) {
                        if itself.exclusive {
                            match event.body {
                                linux_input::InputEventBody::KeyPress( linux_input::Key::LeftAlt ) => pressed_alt = true,
                                linux_input::InputEventBody::KeyRelease( linux_input::Key::LeftAlt ) => pressed_alt = false,
                                linux_input::InputEventBody::KeyPress( linux_input::Key::LeftCtrl ) => pressed_ctrl = true,
                                linux_input::InputEventBody::KeyRelease( linux_input::Key::LeftCtrl ) => pressed_ctrl = false,
                                linux_input::InputEventBody::KeyPress( linux_input::Key::Escape ) => pressed_escape = true,
                                linux_input::InputEventBody::KeyRelease( linux_input::Key::Escape ) => pressed_escape = false,
                                linux_input::InputEventBody::KeyPress( linux_input::Key::Pause ) => pressed_pause = true,
                                linux_input::InputEventBody::KeyRelease( linux_input::Key::Pause ) => pressed_pause = false,
                                _ => {}
                            }

                            if pressed_alt && pressed_ctrl && pressed_escape && pressed_pause {
                                log::warn!( "Emergency exit triggered!" );
                                RUNNING.store( false, Ordering::SeqCst );

                                std::process::exit( 1 );
                            }
                        }

                        log::trace!( "<< {:?}: {:?}", itself.path, event );
                        for script in &itself.scripts {
                            let mut state = script.script_state.lock();
                            state.event = event.clone();
                            std::mem::drop( state );

                            script.eval();
                        }
                    }

                    source = pipe.lock();
                }
            })
        };

        while RUNNING.load( Ordering::Relaxed ) {
            let event = self.device.read( None );
            let event = match event {
                Ok( Some( event ) ) => event,
                Ok( None ) => continue,
                Err( error ) => {
                    if error.raw_os_error() == Some( libc::ENODEV ) {
                        log::info!( "Device disconnected: '{}'", self.info.name );
                    } else {
                        log::warn!( "Failed to read from device '{}' ({:?}): {}", self.info.name, self.path, error );
                    }
                    break;
                }
            };

            match event.body {
                linux_input::InputEventBody::Dropped => {
                    log::warn!( "Buffer overflow on device '{}' ({:?})", self.info.name, self.path );
                    // TODO: Actually handle there: https://www.freedesktop.org/software/libevdev/doc/latest/syn_dropped.html
                },
                _ => {}
            }

            pipe.lock().push( event );
            condvar.notify_all();
        }

        is_running.store( false, Ordering::SeqCst );
        condvar.notify_all();

        let _ = thread_handle.join();
        std::mem::drop( cleanup );
    }
}

fn populate_with_constants( scope: &mut rhai::Scope ) {
    for (name, value) in linux_input::Key::LIST {
        scope.push_constant( format!( "Key_{}", name ), value.raw() as i32 | (EventKind::Key.raw() as i32) << 16 );
    }
    for (name, value) in linux_input::AbsoluteAxis::LIST {
        scope.push_constant( format!( "Abs_{}", name ), value.raw() as i32 | (EventKind::AbsoluteAxis.raw() as i32) << 16 );
    }
    for (name, value) in linux_input::RelativeAxis::LIST {
        scope.push_constant( format!( "Rel_{}", name ), value.raw() as i32 | (EventKind::RelativeAxis.raw() as i32) << 16 );
    }

    for (name, value) in linux_input::EventKind::LIST {
        scope.push_constant( format!( "{}", name ), value.raw() as i32 );
    }

    scope.push_constant( "Rel", linux_input::EventKind::RelativeAxis.raw() as i32 );
    scope.push_constant( "Abs", linux_input::EventKind::AbsoluteAxis.raw() as i32 );
    scope.push_constant( "Sync", linux_input::EventKind::Synchronization.raw() as i32 );

    // TODO: This doesn't work:
    // scope.push_constant( "PI", std::f64::consts::PI );
}

fn create_rhai_engine() -> rhai::Engine {
    use rhai::packages::Package;

    let mut engine = rhai::Engine::new_raw();
    engine.register_global_module( rhai::packages::ArithmeticPackage::new().as_shared_module() );
    engine.register_global_module( rhai::packages::LogicPackage::new().as_shared_module() );
    engine.register_global_module( rhai::packages::BasicStringPackage::new().as_shared_module() );
    engine.register_global_module( rhai::packages::MoreStringPackage::new().as_shared_module() );
    engine.register_global_module( rhai::packages::BasicArrayPackage::new().as_shared_module() );
    engine.register_global_module( rhai::packages::BasicMapPackage::new().as_shared_module() );

    engine.register_fn( "abs", move |value: f64| value.abs() );
    engine.register_fn( "sin", move |value: f64| value.sin() );
    engine.register_fn( "cos", move |value: f64| value.cos() );
    engine.register_fn( "sqrt", move |value: f64| value.sqrt() );
    engine.register_fn( "atan", move |x: f64, y: f64| y.atan2( x ) );
    engine.register_fn( "pi", move || std::f64::consts::PI );
    engine.register_fn( "to_float", move |value: i32| value as f64 );
    engine.register_fn( "to_int", move |value: f64| value as i32 );

    engine
}

struct Script {
    device: String,
    ast: rhai::AST
}

struct ScriptInstance {
    engine: rhai::Engine,
    script: Arc< Script >,
    scope: Mutex< rhai::Scope< 'static > >,
    script_state: Arc< Mutex< ScriptState > >
}

struct ScriptState {
    global_state: Weak< GlobalState >,
    event: linux_input::InputEvent,
    initialized: bool
}

impl ScriptState {
    fn send_event< T >( &self, target: &str, body: T ) where T: AsRef< linux_input::InputEventBody > {
        log::trace!( "send_event: target={:?} body={:?}", target, body.as_ref() );
        let global_state = self.global_state.upgrade().unwrap();
        if let Some( device ) = global_state.lookup_device_by_internal_name( &target ) {
            if let Err( error ) = device.emit( body ) {
                log::error!( "Failed to send an event to '{}': {}", target, error );
            }
        } else {
            log::error!( "[script] send_to: no such device: '{}'", target );
        }
    }
}

fn debug_print_event( event: linux_input::RawInputEvent ) -> String {
    use std::fmt::Write;
    let mut output = String::new();
    let kind = linux_input::EventKind::from( event.kind );
    write!( &mut output, "{{ " ).unwrap();
    write!( &mut output, "timestamp: {:.03}, ", event.timestamp.as_f64() ).unwrap();
    match kind {
        EventKind::Key => {
            write!( &mut output, "type: {}, ", kind ).unwrap();
            match linux_input::Key::from( event.code ) {
                Key::Other( raw_key ) => write!( &mut output, "key: raw_key(0x{:03X}), ", raw_key ).unwrap(),
                key => write!( &mut output, "key: Key_{}, ", key ).unwrap()
            }
            write!( &mut output, "press: {}", event.value == 1 ).unwrap();
        },
        EventKind::AbsoluteAxis => {
            write!( &mut output, "type: Abs, " ).unwrap();
            match linux_input::AbsoluteAxis::from( event.code ) {
                linux_input::AbsoluteAxis::Other( raw_axis ) => write!( &mut output, "axis: raw_abs(0x{:03X}), ", raw_axis ).unwrap(),
                axis => write!( &mut output, "axis: Abs_{}, ", axis ).unwrap()
            }
            write!( &mut output, "position: {}", event.value ).unwrap();
        },
        EventKind::RelativeAxis => {
            write!( &mut output, "type: Rel, " ).unwrap();
            match linux_input::RelativeAxis::from( event.code ) {
                linux_input::RelativeAxis::Other( raw_axis ) => write!( &mut output, "axis: raw_rel(0x{:03X}), ", raw_axis ).unwrap(),
                axis => write!( &mut output, "axis: Rel_{}, ", axis ).unwrap()
            }
            write!( &mut output, "delta: {}", event.value ).unwrap();
        },
        _ => {
            write!( &mut output, "type: {}, ", kind ).unwrap();
            write!( &mut output, "raw_code: {}, ", event.code ).unwrap();
            write!( &mut output, "raw_value: {}", event.value ).unwrap();
        }
    }
    write!( &mut output, " }}" ).unwrap();
    output
}

impl ScriptInstance {
    fn new( global_state: &Arc< GlobalState >, script: Arc< Script > ) -> Self {

        let script_state = ScriptState {
            global_state: Arc::downgrade( global_state ),
            event: linux_input::InputEvent {
                timestamp: linux_input::Timestamp::default(),
                body: linux_input::InputEventBody::Flush
            },
            initialized: false
        };

        let script_state = Arc::new( Mutex::new( script_state ) );
        let mut engine = create_rhai_engine();
        engine.on_print( |str| log::info!( "[script] {}", str ) );
        engine.register_type::< linux_input::RawInputEvent >();
        engine.register_get( "timestamp", (|this| this.timestamp.as_f64()) as fn( &mut linux_input::RawInputEvent ) -> f64 );
        engine.register_get( "type", (|this| this.kind as i32) as fn( &mut linux_input::RawInputEvent ) -> i32 );
        engine.register_get( "raw_code", (|this| this.code as i32) as fn( &mut linux_input::RawInputEvent ) -> i32 );
        engine.register_get( "raw_value", (|this| this.value as i32) as fn( &mut linux_input::RawInputEvent ) -> i32 );
        engine.register_get( "key", (|this|
            if this.kind == linux_input::EventKind::Key.raw() {
                ((this.code as i32) | ((this.kind as i32) << 16)).into()
            } else {
                ().into()
            }) as fn( &mut linux_input::RawInputEvent ) -> rhai::Dynamic );
        engine.register_get( "axis", (|this|
            if this.kind == linux_input::EventKind::AbsoluteAxis.raw() || this.kind == linux_input::EventKind::RelativeAxis.raw() {
                ((this.code as i32) | ((this.kind as i32) << 16)).into()
            } else {
                ().into()
            }) as fn( &mut linux_input::RawInputEvent ) -> rhai::Dynamic );
        engine.register_get( "position", (|this|
            if this.kind == linux_input::EventKind::AbsoluteAxis.raw() {
                (this.value as i32).into()
            } else {
                ().into()
            }) as fn( &mut linux_input::RawInputEvent ) -> rhai::Dynamic );
        engine.register_get( "delta", (|this|
            if this.kind == linux_input::EventKind::AbsoluteAxis.raw() {
                (this.value as i32).into()
            } else {
                ().into()
            }) as fn( &mut linux_input::RawInputEvent ) -> rhai::Dynamic );
        engine.register_get( "press", (|this| this.kind == linux_input::EventKind::Key.raw() && this.value != 0) as fn( &mut linux_input::RawInputEvent ) -> bool );
        engine.register_get( "release", (|this| this.kind == linux_input::EventKind::Key.raw() && this.value == 0) as fn( &mut linux_input::RawInputEvent ) -> bool );

        engine.register_fn( "raw_key", |key: i32| key | ((linux_input::EventKind::Key.raw() as i32) << 16) );
        engine.register_fn( "raw_rel", |axis: i32| axis | ((linux_input::EventKind::RelativeAxis.raw() as i32) << 16) );
        engine.register_fn( "raw_abs", |axis: i32| axis | ((linux_input::EventKind::AbsoluteAxis.raw() as i32) << 16) );

        engine.register_fn( "print", move |event: linux_input::RawInputEvent| {
            debug_print_event( event )
        });

        {
            let script_state = script_state.clone();
            engine.register_fn( "send_to", move |target: String| {
                log::trace!( "script: send_to: target={:?}", target );
                let script_state = script_state.lock();
                script_state.send_event( &target, script_state.event.clone() );
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_keypress", move |target: String, key: i32| {
                let script_state = script_state.lock();
                let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                script_state.send_event( &target, linux_input::InputEventBody::KeyPress( key ) );
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_keypress", move |target: String, keys: rhai::Array| {
                let script_state = script_state.lock();
                for item in keys {
                    if let Some( key ) = item.try_cast::< i32 >() {
                        let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                        script_state.send_event( &target, linux_input::InputEventBody::KeyPress( key ) );
                    } else {
                        log::error!( "[script] send_keypress: array contains invalid value" );
                    }
                }
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_keyrelease", move |target: String, key: i32| {
                let script_state = script_state.lock();
                let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                script_state.send_event( &target, linux_input::InputEventBody::KeyRelease( key ) );
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_keyrelease", move |target: String, keys: rhai::Array| {
                let script_state = script_state.lock();
                for item in keys.into_iter().rev() {
                    if let Some( key ) = item.try_cast::< i32 >() {
                        let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                        script_state.send_event( &target, linux_input::InputEventBody::KeyRelease( key ) );
                    } else {
                        log::error!( "[script] send_keyrelease: array contains invalid value" );
                    }
                }
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_key", move |target: String, key: i32| {
                log::trace!( "script: send_key: target={:?} key={:?}", target, key );
                let script_state = script_state.lock();
                let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                script_state.send_event( &target, linux_input::InputEventBody::KeyPress( key ) );
                script_state.send_event( &target, linux_input::InputEventBody::KeyRelease( key ) );
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_key", move |target: String, key: i32, press: bool| {
                log::trace!( "script: send_key: target={:?} key={:?} press={:?}", target, key, press );
                let script_state = script_state.lock();
                let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                let event = if press {
                    linux_input::InputEventBody::KeyPress( key )
                } else {
                    linux_input::InputEventBody::KeyRelease( key )
                };
                script_state.send_event( &target, event );
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_key", move |target: String, keys: rhai::Array| {
                let script_state = script_state.lock();
                for item in keys.iter() {
                    if let Some( key ) = item.clone().try_cast::< i32 >() {
                        let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                        script_state.send_event( &target, linux_input::InputEventBody::KeyPress( key ) );
                    } else {
                        log::error!( "[script] send_key: array contains invalid value" );
                    }
                }
                for item in keys.into_iter().rev() {
                    if let Some( key ) = item.clone().try_cast::< i32 >() {
                        let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                        script_state.send_event( &target, linux_input::InputEventBody::KeyRelease( key ) );
                    }
                }
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_key", move |target: String, mut keys: rhai::Array, press: bool| {
                let script_state = script_state.lock();
                if !press {
                    keys.reverse();
                }
                for item in keys {
                    if let Some( key ) = item.clone().try_cast::< i32 >() {
                        let key = linux_input::Key::from( (key & 0xFFFF) as u16 );
                        let event = if press {
                            linux_input::InputEventBody::KeyPress( key )
                        } else {
                            linux_input::InputEventBody::KeyRelease( key )
                        };
                        script_state.send_event( &target, event );
                    } else {
                        log::error!( "[script] send_key: array contains invalid value" );
                    }
                }
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_abs", move |target: String, axis: i32, position: i32| {
                let script_state = script_state.lock();
                let axis = linux_input::AbsoluteAxis::from( (axis & 0xFFFF) as u16 );
                script_state.send_event( &target, linux_input::InputEventBody::AbsoluteMove { axis, position } );
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_rel", move |target: String, axis: i32, delta: i32| {
                let script_state = script_state.lock();
                let axis = linux_input::RelativeAxis::from( (axis & 0xFFFF) as u16 );
                script_state.send_event( &target, linux_input::InputEventBody::RelativeMove { axis, delta } );
            });
        }
        {
            let script_state = script_state.clone();
            engine.register_fn( "send_flush", move |target: String| {
                let script_state = script_state.lock();
                script_state.send_event( &target, linux_input::InputEventBody::Flush );
            });
        }

        engine.register_fn( "run", move |command: String| {
            let _ = std::process::Command::new( "sh" )
                .arg( "-c" )
                .arg( command )
                .spawn();
        });

        let mut scope = rhai::Scope::new();
        populate_with_constants( &mut scope );
        scope.push( "state", rhai::Map::new() );

        ScriptInstance {
            engine,
            script_state,
            script,
            scope: Mutex::new( scope )
        }
    }

    fn eval( &self ) {
        let mut scope = self.scope.lock();

        {
            let mut script_state = self.script_state.lock();
            let raw_event: linux_input::RawInputEvent = script_state.event.clone().into();
            scope.push( "first_run", !script_state.initialized );
            scope.push( "event", raw_event );
            script_state.initialized = true;
        }

        // scope.push( "state", user_state );
        let scope_length = scope.len();
        let result = self.engine.eval_ast_with_scope::< rhai::Dynamic >( &mut scope, &self.script.ast );
        scope.rewind( scope_length );

        if let Err( error ) = result {
            log::error!( "Error while evaluating script: {}", error );
        }
    }
}

impl GlobalState {
    fn new( config: Config ) -> Option< Arc< Self > > {
        let mut scripts = Vec::new();
        let engine = create_rhai_engine();
        for script in &config.scripts {
            let ast = engine.compile( &script.code ).unwrap();
            let mut scope = rhai::Scope::new();
            populate_with_constants( &mut scope );
            let ast = engine.optimize_ast( &scope, ast, rhai::OptimizationLevel::Simple );
            scripts.push( Arc::new( Script {
                device: script.device.clone(),
                ast
            }));
        }
        std::mem::drop( engine );

        let global_state = GlobalState {
            config,
            scripts,
            devices_by_internal_name: Default::default(),
            virtual_device_by_rdev: Default::default(),
            virtual_device_by_internal_name: Default::default(),
        };

        let global_state = Arc::new( global_state );

        let mut virtual_device_by_rdev = HashMap::new();
        let mut virtual_device_by_internal_name = HashMap::new();
        for (virtual_device_name, virtual_device_config) in &global_state.config.virtual_devices {
            // Not that it really matters, but the defaults come from here:
            // https://github.com/obdev/v-usb/blob/master/usbdrv/USB-IDs-for-free.txt
            let id = DeviceId {
                bus: virtual_device_config.bus.unwrap_or( Bus::USB ),
                vendor: virtual_device_config.vendor.unwrap_or( 0x16c0 ),
                product: virtual_device_config.product.unwrap_or_else( || {
                    match virtual_device_config.preset {
                        Some( crate::config::DevicePreset::Keyboard ) => 0x27db,
                        Some( crate::config::DevicePreset::Mouse ) => 0x27da,
                        None => 0x27d9
                    }
                }),
                version: virtual_device_config.version.unwrap_or( 0x0111 )
            };

            let name = virtual_device_config.name.as_ref().map( |name| name.as_str() ).unwrap_or( &virtual_device_name );
            let mut event_bits = Vec::new();

            match virtual_device_config.preset {
                Some( crate::config::DevicePreset::Keyboard ) => {
                    use Key::*;
                    let keys = &[
                        A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
                        F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
                        Digit0, Digit1, Digit2, Digit3, Digit4, Digit5, Digit6, Digit7, Digit8, Digit9,
                        Grave, LeftBrace, RightBrace,
                        Down, Left, Right, Up,
                        Backspace, Enter, Space, Tab, Escape,
                        LeftAlt, RightAlt,
                        LeftShift, RightShift,
                        LeftCtrl, RightCtrl,
                        LeftMeta, RightMeta,
                        Apostrophe, Backslash, Comma, Dot, Equal, Minus, Semicolon, Slash,
                        Delete, End, Home, Insert, PageDown, PageUp,
                        Pause, SysRq,
                        CapsLock, NumLock, ScrollLock,
                        Keypad0, Keypad1, Keypad2, Keypad3, Keypad4, Keypad5, Keypad6, Keypad7, Keypad8, Keypad9,
                        KeypadAsterisk, KeypadComma, KeypadDot, KeypadEnter, KeypadEqual, KeypadMinus, KeypadPlus, KeypadSlash
                    ];

                    for &key in keys.iter() {
                        event_bits.push( EventBit::Key( key ) );
                    }
                },
                Some( crate::config::DevicePreset::Mouse ) => {
                    event_bits.push( EventBit::Key( Key::MouseLeft ) );
                    event_bits.push( EventBit::Key( Key::MouseRight ) );
                    event_bits.push( EventBit::Key( Key::MouseMiddle ) );
                    event_bits.push( EventBit::Key( Key::MouseExtra1 ) );
                    event_bits.push( EventBit::Key( Key::MouseExtra2 ) );
                    event_bits.push( EventBit::Key( Key::MouseExtra3 ) );
                    event_bits.push( EventBit::Key( Key::MouseExtra4 ) );
                    event_bits.push( EventBit::Key( Key::MouseExtra5 ) );
                    event_bits.push( EventBit::RelativeAxis( RelativeAxis::X ) );
                    event_bits.push( EventBit::RelativeAxis( RelativeAxis::Y ) );
                    event_bits.push( EventBit::RelativeAxis( RelativeAxis::Wheel ) );
                },
                None => {}
            }

            for &bit in &virtual_device_config.key_bits {
                event_bits.push( EventBit::Key( bit ) );
            }

            for &bit in &virtual_device_config.rel_bits {
                event_bits.push( EventBit::RelativeAxis( bit ) );
            }

            for bit in &virtual_device_config.abs_bits {
                event_bits.push( EventBit::AbsoluteAxis( bit.clone() ) );
            }

            for &bit in &virtual_device_config.ff_bits {
                event_bits.push( EventBit::ForceFeedback( bit ) );
            }

            let device = linux_input::VirtualDevice::create( id, name, event_bits )
                .expect( "failed to create a virtual device" );

            let path = device.path().unwrap();
            let rdev = get_rdev( &path ).unwrap();

            log::info!( "Created a new virtual device: '{}' ({:?})", virtual_device_name, path );
            let virtual_device = VirtualDeviceState {
                global_state: Arc::downgrade( &global_state ),
                internal_name: virtual_device_name.clone(),
                rdev,
                path,
                device
            };

            let virtual_device = Arc::new( virtual_device );
            virtual_device_by_rdev.insert( rdev, virtual_device.clone() );
            virtual_device_by_internal_name.insert( virtual_device_name.clone(), virtual_device.clone() );

            if !virtual_device_config.ff_bits.is_empty() {
                if let Some( ref target ) = virtual_device_config.redirect_force_feedback_to {
                    let target = target.clone();
                    std::thread::spawn( move || virtual_device.force_feedback_thread_main( target ) );
                }
            }
        }

        std::thread::sleep( std::time::Duration::from_millis( 500 ) );
        for (virtual_device_name, virtual_device_config) in &global_state.config.virtual_devices {
            if let Some( chmod ) = virtual_device_config.chmod {
                let virtual_device = virtual_device_by_internal_name.get( virtual_device_name ).unwrap();
                use std::os::unix::fs::PermissionsExt;
                if let Err( error ) = std::fs::set_permissions( &virtual_device.path, std::fs::Permissions::from_mode( chmod as u32 ) ) {
                    log::error!( "Failed to chmod the '{}' ({:?}) virtual device to {:04o}: {}", virtual_device_name, virtual_device.path, chmod, error );
                    return None;
                }
            }
        }

        *global_state.virtual_device_by_rdev.write() = virtual_device_by_rdev;
        *global_state.virtual_device_by_internal_name.write() = virtual_device_by_internal_name;

        Some( global_state )
    }

    fn lookup_device_by_internal_name( &self, internal_name: &str ) -> Option< AnyDeviceState > {
        if let Some( virtual_device ) = self.virtual_device_by_internal_name.read().get( internal_name ) {
            Some( AnyDeviceState::Virtual( virtual_device.clone() ) )
        } else if let Some( devices ) = self.devices_by_internal_name.read().get( internal_name ) {
            if !devices.is_empty() {
                Some( AnyDeviceState::Physical( devices[0].clone() ) )
            } else {
                None
            }
        } else {
            None
        }
    }

    fn on_new_device( self: &Arc< Self >, path: &Path ) -> bool {
        let rdev = match get_rdev( path ) {
            Ok( rdev ) => rdev,
            Err( error ) => {
                log::trace!( "Can't stat {:?}: {}", path, error );
                return false
            }
        };

        if self.virtual_device_by_rdev.read().contains_key( &rdev ) {
            return false;
        }

        let device_with_info = Device::open( &path ).ok().and_then( |mut device| {
            let info = DeviceInfo::get( &mut device )?;
            Some( (device, info) )
        });

        let (device, info) = match device_with_info {
            Some( device_with_info ) => device_with_info,
            None => {
                return false;
            }
        };

        log::info!( "Found a new device in {:?}: '{}'", path, info.name );
        let mut exclusive = false;
        let mut chmod = None;
        let mut matched_filters = Vec::new();
        for (device_filter_name, device_filter) in &self.config.device_filters {
            if info.match_with_config( device_filter ) {
                matched_filters.push( device_filter_name.to_owned() );
                exclusive |= device_filter.exclusive;
                if let Some( value ) = device_filter.chmod {
                    chmod = Some( value );
                }
            }
        }

        if matched_filters.is_empty() {
            return false;
        }

        log::info!( "  Device '{}' matches the following filters:", info.name );
        for name in &matched_filters {
            log::info!( "    '{}'", name );
        }

        if exclusive {
            if let Err( error ) = device.grab() {
                log::error!( "  Failed to turn on the exclusive mode for '{}': {}", info.name, error );
                std::process::exit( 1 );
            }

            log::info!( "  Exclusive mode turned on for '{}'", info.name );
        }

        let mut old_permissions = None;
        if let Some( chmod ) = chmod {
            use std::os::unix::fs::PermissionsExt;
            let metadata = std::fs::metadata( path );
            if let Err( error ) = std::fs::set_permissions( &path, std::fs::Permissions::from_mode( chmod as u32 ) ) {
                log::error!( "Failed to chmod the '{}' ({:?}) device to {:04o}: {}", info.name, path, chmod, error );
            } else {
                if let Ok( metadata ) = metadata {
                    old_permissions = Some( metadata.permissions() );
                }
            }
        }

        let mut scripts = Vec::new();
        for script in &self.scripts {
            if matched_filters.contains( &script.device ) {
                scripts.push( ScriptInstance::new( self, script.clone() ) );
            }
        }

        let state = DeviceState {
            global_state: Arc::downgrade( self ),
            path: path.to_owned(),
            device,
            info,
            matched_filters,
            scripts,
            old_permissions,
            exclusive
        };

        let state = Arc::new( state );
        {
            let mut devices_by_internal_name = self.devices_by_internal_name.write();
            for internal_name in &state.matched_filters {
                devices_by_internal_name.entry( internal_name.clone() ).or_insert_with( Vec::new ).push( state.clone() );
            }
        }

        std::thread::spawn( move || state.thread_main() );
        true
    }
}

fn run( config: Config ) {
    let mut monitor = udev::MonitorBuilder::new().unwrap()
        .match_subsystem( "input" ).unwrap()
        .listen().unwrap();

    let state = match GlobalState::new( config ) {
        Some( state ) => state,
        None => {
            std::process::exit( 1 );
        }
    };

    let mut present_devices = HashSet::new();
    let paths = list_devices();
    for path in paths {
        if state.on_new_device( &path ) {
            present_devices.insert( path );
        }
    }

    use std::os::unix::io::AsRawFd;
    while RUNNING.load( Ordering::Relaxed ) {
        if linux_input::poll_read( monitor.as_raw_fd(), None ).unwrap() {
            let event = monitor.next().unwrap();
            let devnode = event.devnode();
            log::debug!(
                "Device event: type={:?}, devpath={:?}, devnode={:?}",
                event.event_type(),
                event.devpath(),
                devnode
            );

            let devnode = match devnode {
                None => continue,
                Some( devnode ) => devnode
            };

            if !devnode.starts_with( "/dev/input" ) ||
               devnode.components().count() != 4 ||
               !devnode.file_name().unwrap().to_str().unwrap().starts_with( "event" ) {
                continue;
            }

            match event.event_type() {
                udev::EventType::Add => {
                    if present_devices.contains( devnode ) {
                        continue;
                    }
                },
                udev::EventType::Remove => {
                    present_devices.remove( devnode );
                },
                _ => continue
            }

            if event.event_type() == udev::EventType::Add {
                if state.on_new_device( devnode ) {
                    present_devices.insert( devnode.to_owned() );
                }
            }
        }
    }

    let devices: Vec< _ > = state.devices_by_internal_name.read().values().flat_map( |devices| devices.iter() ).cloned().collect();
    for device in devices {
        if let Some( ref old_permissions ) = device.old_permissions {
            let _ = std::fs::set_permissions( &device.path, old_permissions.clone() );
        }
    }
}

fn set_signal_handler() {
    unsafe {
        fn signal_handler( _: libc::c_int ) {
            RUNNING.store( false, Ordering::SeqCst );
        }

        for &signal in &[libc::SIGINT, libc::SIGTERM] {
            if libc::signal( signal, signal_handler as libc::size_t ) == libc::SIG_ERR {
                panic!( "signal failed: {}", std::io::Error::last_os_error() );
            }
        }
    }
}

fn main() {
    if std::env::var( "RUST_LOG" ).is_err() {
        std::env::set_var( "RUST_LOG", "info" );
    }

    env_logger::init();

    let opt = Opt::from_args();
    match opt {
        Opt::PrintEvents { path, exclusive } => {
            let device = Device::open( path ).unwrap();
            set_signal_handler();

            if exclusive {
                device.grab().unwrap();
            }

            let start = linux_input::Timestamp::get().unwrap();
            let start_realtime = std::time::SystemTime::now();

            while RUNNING.load( Ordering::Relaxed ) {
                let event = device.read( Some( std::time::Duration::from_millis( 50 ) ) );
                let event = match event {
                    Err( _ ) => break,
                    Ok( Some( event ) ) => event,
                    Ok( None ) => continue
                };

                let timestamp = start_realtime + (event.timestamp - start);
                let raw_event: linux_input::RawInputEvent = event.into();
                println!( "{}: {}", humantime::format_rfc3339_micros( timestamp ), debug_print_event( raw_event ) );
            }
        },
        Opt::List { mut all, mut paths } => {
            let mut total_count = 0;
            let mut failure_count = 0;
            let mut skipped_count = 0;
            if paths.is_empty() {
                paths = list_devices();
            } else {
                all = true;
            }

            for path in paths {
                total_count += 1;
                let info = match Device::open( &path ).ok().and_then( |mut device| DeviceInfo::get( &mut device ) ) {
                    Some( info ) => info,
                    None => {
                        failure_count += 1;
                        continue;
                    }
                };

                if !all {
                    let should_skip =
                        (info.key_bits.is_empty() && info.relative_axis_bits.is_empty() && info.absolute_axis_bits.is_empty()) ||
                        (info.key_bits.len() == 1 && info.relative_axis_bits.is_empty() && info.absolute_axis_bits.is_empty()) ||
                        (info.key_bits.is_empty() && info.relative_axis_bits.is_empty() && info.absolute_axis_bits.len() == 1) ||
                        info.name == "Power Button";

                    if should_skip {
                        skipped_count += 1;
                        continue;
                    }
                }

                println!( "{}", path.to_str().unwrap() );
                println!( "       Name: \"{}\"", info.name );
                println!( "        Bus: {}", info.id.bus );
                println!( "     Vendor: 0x{:04X}", info.id.vendor );
                println!( "    Product: 0x{:04X}", info.id.product );
                println!( "    Version: 0x{:04X}", info.id.version );
                if let Some( kind ) = info.guess_type() {
                    println!( "       Kind: {}", kind );
                }

                if !info.key_bits.is_empty() {
                    println!( "       Keys: {}", info.key_bits.len() );
                    let mut bits_s = Vec::new();
                    for bit in info.key_bits {
                        bits_s.push( (bit.raw(), bit.to_string()) );
                    }
                    fn get_category( raw: u16, name: &str ) -> usize {
                        if name.len() == 1 {
                            0
                        } else if name.starts_with( "F" ) && name.len() == 2 {
                            1
                        } else if name == "F10" || name == "F11" || name == "F12" {
                            2
                        } else if name.len() == 6 && name.starts_with( "Digit" ) {
                            3
                        } else if name == "Left" || name == "Right" || name == "Up" || name == "Down" {
                            5
                        } else if name == "Grave" || name == "LeftBrace" || name == "RightBrace" {
                            4
                        } else if name == "Backspace" || name == "Enter" || name == "Space" || name == "Tab" {
                            6
                        } else if name == "Escape" {
                            7
                        } else if name == "LeftAlt" || name == "RightAlt" {
                            8
                        } else if name == "LeftShift" || name == "RightShift" {
                            9
                        } else if name == "LeftCtrl" || name == "RightCtrl" {
                            10
                        } else if name == "LeftMeta" || name == "RightMeta" {
                            11
                        } else if name == "Insert" || name == "Delete" || name == "Home" || name == "End" || name == "PageUp" || name == "PageDown" {
                            13
                        } else if name == "CapsLock" || name == "ScrollLock" || name == "NumLock" {
                            15
                        } else if name == "Pause" || name == "SysRq" {
                            14
                        } else if name == "Apostrophe" || name == "Backslash" || name == "Comma" || name == "Dot" || name == "Equal" || name == "Minus" || name == "Semicolon" || name == "Slash" {
                            12
                        } else if name.starts_with( "Keypad" ) {
                            16
                        } else if name.starts_with( "0x" ) {
                            255
                        } else if raw < 255 {
                            100
                        } else {
                            101
                        }
                    }
                    bits_s.sort_by( |(a_raw, a), (b_raw, b)| {
                        get_category( *a_raw, &a ).cmp( &get_category( *b_raw, &b ) ).then( a.cmp( b ) )
                    });
                    let mut line = String::new();
                    for (_, bit) in bits_s {
                        if !line.is_empty() {
                            if line.len() + bit.len() + 1 >= 72 {
                                println!( "      {}", line );
                                line.clear();
                            } else {
                                line.push( ' ' );
                            }
                        }
                        line.push_str( &bit );
                    }
                    if !line.is_empty() {
                        println!( "      {}", line );
                    }
                }

                if !info.relative_axis_bits.is_empty() {
                    println!( "  Rel. axis: {}", info.relative_axis_bits.len() );
                    for bit in info.relative_axis_bits {
                        println!( "      {}", bit.to_string() );
                    }
                }

                if !info.absolute_axis_bits.is_empty() {
                    println!( "  Abs. axis: {}", info.absolute_axis_bits.len() );
                    for bit in info.absolute_axis_bits {
                        println!(
                            "      {} (min={}, max={}, noise_threshold={}, deadzone={}, resolution={})",
                            bit.axis.to_string(), bit.minimum, bit.maximum, bit.noise_threshold, bit.deadzone, bit.resolution
                        );
                    }
                }

                println!();
            }

            println!( "Found {} device(s) in total.", total_count );
            if failure_count > 0 {
                println!( "Failed to open {} device(s).", failure_count );
            }
            if skipped_count > 0 {
                println!( "Skipped {} uninteresting device(s).", skipped_count );
            }
            println!();
        },
        Opt::Start { config } => {
            let config = match Config::load_from_file( &config ) {
                Ok( config ) => config,
                Err( error ) => {
                    eprintln!( "Failed to load the config file from {:?}: {}", config, error );
                    std::process::exit( 1 );
                }
            };

            set_signal_handler();
            run( config );
        }
    }
}
